import '../entities/order.dart';
import '../entities/user.dart';
import '../repositories/order_repository.dart';
import '../repositories/store_repository.dart';
import '../repositories/product_repository.dart';
import '../repositories/user_repository.dart';

class CreateOrderUseCase {
  final OrderRepository _orderRepository;
  final StoreRepository _storeRepository;
  final ProductRepository _productRepository;
  final UserRepository _userRepository;

  CreateOrderUseCase(
    this._orderRepository,
    this._storeRepository,
    this._productRepository,
    this._userRepository,
  );

  Future<Order> execute({
    required String customerId,
    required String storeId,
    required List<OrderItemRequest> items,
    required String deliveryAddress,
    required double deliveryLatitude,
    required double deliveryLongitude,
    String? notes,
  }) async {
    try {
      // Validate customer exists
      final customer = await _userRepository.getUserById(customerId);
      if (!customer.isActive) {
        throw Exception('Customer account is not active');
      }

      // Validate store exists and is active
      final store = await _storeRepository.getStoreById(storeId);
      if (!store.isActive) {
        throw Exception('Store is currently closed');
      }

      // Calculate delivery cost
      final deliveryCost = await _storeRepository.getDeliveryCost(
        storeId,
        deliveryLatitude,
        deliveryLongitude,
      );

      // Calculate estimated delivery time
      final estimatedTime = await _storeRepository.getEstimatedDeliveryTime(
        storeId,
        deliveryLatitude,
        deliveryLongitude,
      );

      // Validate products and calculate subtotal
      double subtotal = 0.0;
      for (final item in items) {
        final product = await _productRepository.getProductById(item.productId);
        if (!product.isActive) {
          throw Exception('Product ${product.name} is not available');
        }
        if (product.stockQuantity < item.quantity) {
          throw Exception('Insufficient stock for product: ${product.name}');
        }
        subtotal += product.price * item.quantity;
      }

      final order = Order(
        id: '', // Will be generated by repository
        customerId: customerId,
        storeId: storeId,
        status: OrderStatus.pending,
        subtotal: subtotal,
        deliveryFee: deliveryCost,
        total: subtotal + deliveryCost,
        paymentMethod: PaymentMethod.cash,
        isPaid: false,
        deliveryAddress: deliveryAddress,
        deliveryLatitude: deliveryLatitude,
        deliveryLongitude: deliveryLongitude,
        notes: notes,
        estimatedDeliveryTime: estimatedTime,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      return await _orderRepository.createOrder(order);
    } catch (e) {
      throw Exception('Failed to create order: ${e.toString()}');
    }
  }
}

class OrderItemRequest {
  final String productId;
  final int quantity;

  const OrderItemRequest({
    required this.productId,
    required this.quantity,
  });
}

class GetOrderByIdUseCase {
  final OrderRepository _orderRepository;

  GetOrderByIdUseCase(this._orderRepository);

  Future<Order> execute(String orderId) async {
    try {
      if (orderId.isEmpty) {
        throw Exception('Order ID is required');
      }
      return await _orderRepository.getOrderById(orderId);
    } catch (e) {
      throw Exception('Failed to get order: ${e.toString()}');
    }
  }
}

class GetOrdersByCustomerUseCase {
  final OrderRepository _orderRepository;

  GetOrdersByCustomerUseCase(this._orderRepository);

  Future<List<Order>> execute(String customerId, {int limit = 20, int offset = 0}) async {
    try {
      if (customerId.isEmpty) {
        throw Exception('Customer ID is required');
      }
      return await _orderRepository.getOrdersByCustomer(customerId, limit: limit, offset: offset);
    } catch (e) {
      throw Exception('Failed to get customer orders: ${e.toString()}');
    }
  }
}

class GetOrdersByStoreUseCase {
  final OrderRepository _orderRepository;

  GetOrdersByStoreUseCase(this._orderRepository);

  Future<List<Order>> execute(String storeId, {int limit = 20, int offset = 0}) async {
    try {
      if (storeId.isEmpty) {
        throw Exception('Store ID is required');
      }
      return await _orderRepository.getOrdersByStore(storeId, limit: limit, offset: offset);
    } catch (e) {
      throw Exception('Failed to get store orders: ${e.toString()}');
    }
  }
}

class UpdateOrderStatusUseCase {
  final OrderRepository _orderRepository;

  UpdateOrderStatusUseCase(this._orderRepository);

  Future<Order> execute(String orderId, OrderStatus newStatus, String updatedBy, {String? notes}) async {
    try {
      if (orderId.isEmpty) {
        throw Exception('Order ID is required');
      }
      if (updatedBy.isEmpty) {
        throw Exception('Updated by user ID is required');
      }

      return await _orderRepository.updateOrderStatus(orderId, newStatus, updatedBy, notes: notes);
    } catch (e) {
      throw Exception('Failed to update order status: ${e.toString()}');
    }
  }
}

class CancelOrderUseCase {
  final OrderRepository _orderRepository;

  CancelOrderUseCase(this._orderRepository);

  Future<Order> execute(String orderId, String cancelledBy, String reason) async {
    try {
      if (orderId.isEmpty) {
        throw Exception('Order ID is required');
      }
      if (cancelledBy.isEmpty) {
        throw Exception('Cancelled by user ID is required');
      }
      if (reason.isEmpty) {
        throw Exception('Cancellation reason is required');
      }

      return await _orderRepository.cancelOrder(orderId, cancelledBy, reason);
    } catch (e) {
      throw Exception('Failed to cancel order: ${e.toString()}');
    }
  }
}

class AssignDeliveryPersonUseCase {
  final OrderRepository _orderRepository;
  final UserRepository _userRepository;

  AssignDeliveryPersonUseCase(this._orderRepository, this._userRepository);

  Future<Order> execute(String orderId, String deliveryPersonId) async {
    try {
      if (orderId.isEmpty) {
        throw Exception('Order ID is required');
      }
      if (deliveryPersonId.isEmpty) {
        throw Exception('Delivery person ID is required');
      }

      // Validate delivery person exists and is active
      final deliveryPerson = await _userRepository.getUserById(deliveryPersonId);
      if (deliveryPerson.role != UserRole.repartidor) {
        throw Exception('User is not a delivery person');
      }
      if (!deliveryPerson.isActive) {
        throw Exception('Delivery person is not active');
      }

      final estimatedTime = DateTime.now().add(const Duration(minutes: 30));
      return await _orderRepository.assignDeliveryPerson(orderId, deliveryPersonId, estimatedTime);
    } catch (e) {
      throw Exception('Failed to assign delivery person: ${e.toString()}');
    }
  }
}

class GetOrderStatsUseCase {
  final OrderRepository _orderRepository;

  GetOrderStatsUseCase(this._orderRepository);

  Future<Map<String, dynamic>> execute(DateTime startDate, DateTime endDate, {String? storeId}) async {
    try {
      return await _orderRepository.getOrderStats(startDate, endDate, storeId: storeId);
    } catch (e) {
      throw Exception('Failed to get order stats: ${e.toString()}');
    }
  }
}

class GetPendingOrdersUseCase {
  final OrderRepository _orderRepository;

  GetPendingOrdersUseCase(this._orderRepository);

  Future<List<Order>> execute({String? storeId}) async {
    try {
      return await _orderRepository.getPendingOrders(storeId: storeId);
    } catch (e) {
      throw Exception('Failed to get pending orders: ${e.toString()}');
    }
  }
}

class ConfirmOrderDeliveryUseCase {
  final OrderRepository _orderRepository;

  ConfirmOrderDeliveryUseCase(this._orderRepository);

  Future<Order> execute(String orderId, String deliveredBy, {String? notes}) async {
    try {
      if (orderId.isEmpty) {
        throw Exception('Order ID is required');
      }
      if (deliveredBy.isEmpty) {
        throw Exception('Delivered by user ID is required');
      }

      return await _orderRepository.confirmDelivery(orderId, deliveredBy, deliveryNotes: notes);
    } catch (e) {
      throw Exception('Failed to confirm delivery: ${e.toString()}');
    }
  }
}